###### 四、更多的 bash shell 命令

1. 探查进程
- 当程序在系统中运行时，它被称为进程（process）。要想监测这些进程，必须熟悉 ps 命令的用法。 ps 命令能够输出系统中运行的所有程序的大量信息。
- 在默认情况下， ps 命令并没有提供太多的信息。ps 命令默认只显示运行在当前终端中属于当前用户的那些进程。
- shell 只是运行在系统中的另一个程序而已。
- ps 命令的基本输出显示了程序的进程 ID（process ID，PID ）、进程运行在哪个终端（TTY）及其占用的 CPU 时间。
- Linux 系统中使用的 GNU ps 命令支持以下 3 种类型的命令行选项：
    - Unix 风格选项，选项前加单连字符；
    - BSD 风格选项，选项前不加连字符；
    - GNU 长选项，选项前加双连字符。

2. Unix 风格的ps 命令选项
    选项        | 描述
    ---         | ---
    -A          | 显示所有进程
    -N          | 显示与指定参数不符的所有进程
    -a          | 显示除控制进程（session leader）和无终端进程外的所有进程
    -d          | 显示除控制进程外的所有进程
    -e          | 显示所有进程
    -C cmdlist  | 显示包含在 cmdlist 列表中的进程
    -G grplist  | 显示组 ID 在 grplist 列表中的进程
    -U userlist | 显示属主的用户 ID 在 userlist 列表中的进程
    -g grplist  | 显示会话或组 ID 在 grplist 列表中的进程
    -p pidlist  | 显示 PID 在 pidlist 列表中的进程
    -s sesslist | 显示会话 ID 在 sesslist 列表中的进程
    -t ttylist  | 显示终端 ID 在 ttylist 列表中的进程
    -u userlist | 显示有效用户 ID 在 userlist 列表中的进程
    -F          | 显示更多的额外输出（相对-f 选项而言）
    -O          | 显示默认的输出列以及 format 列表指定的特定列
    -M          | 显示进程的安全信息
    -c          | 显示进程的额外的调度器信息
    -f          | 显示完整格式的输出
    -j          | 显示作业信息
    -l          | 显示长列表
    -o format   | 仅显示由 format 指定的列
    -y          | 不显示进程标志
    -Z          | 显示安全上下文信息
    -H          | 以层级格式显示进程（显示父进程）
    -n namelist | 定义要在 WCHAN 输出列中显示的值
    -w          | 采用宽输出格式，不限宽度显示
    -L          | 显示进程中的线程
    -V          | 显示 ps 命令的版本号

- 使用 ps 命令的关键不在于记住所有可用的选项，而在于记住对你来说最有用的那些。
- 如果需要查看系统中运行的所有进程，可以使用-ef 选项组合（ps 命令允许像这样把选项合并在一起）。
- -f 选项则扩充输出内容以显示一些有用的信息列。
    - UID ：启动该进程的用户。
    - PID：进程 ID。
    - PPID：父进程的 PID（如果该进程是由另一个进程启动的）。
    - C：进程生命期中的 CPU 利用率。
    - STIME ：进程启动时的系统时间。
    - TTY ：进程是从哪个终端设备启动的。
    - TIME：运行进程的累计 CPU 时间。
    - CMD ：启动的程序名称。
- 使用了-l 选项之后多出的那几列:
    - F ：内核分配给进程的系统标志。
    - S：进程的状态（ O 代表正在运行； S 代表在休眠； R 代表可运行，正等待运行； Z 代表僵化，已终止但找不到其父进程； T 代表停止）。
    - PRI ：进程的优先级（数字越大，优先级越低）。
    - NI：谦让度（nice），用于决定优先级。
    - ADDR ：进程的内存地址。
    - SZ ：进程被换出时所需交换空间的大致大小。
    - WCHAN ：进程休眠的内核函数地址。

3. BSD 风格的ps 命令选项
    选项        | 描述
    ---         |---
    T           | 显示与当前终端关联的所有进程
    a           | 显示与任意终端关联的所有进程
    g           | 显示包括控制进程在内的所有进程
    r           | 仅显示运行中的进程
    x           | 显示所有进程， 包括未分配任何终端的进程
    U userlist  | 显示属于 userlist 列表中某个用户 ID 所有的进程
    p pidlist   | 显示 PID 在 pidlist 列表中的进程
    t ttylist   | 显示与 ttylist 列表中的某个终端关联的进程
    O format    | 除了标准列，还输出由 format 指定的列
    X           | 以寄存器格式显示数据
    Z           | 在输出中包含安全信息
    j           | 显示作业信息
    l           | 采用长格式显示
    o format    | 仅显示由 format 指定的列
    s           | 采用信号格式显示
    u           | 采用基于用户的格式显示
    v           | 采用虚拟内存格式显示
    N namelist  | 定义要在 WCHAN 输出列中显示的值
    O order     | 定义信息列的显示顺序
    S           | 将子进程的数值统计信息（比如 CPU 和内存使用情况）汇总到父进程中
    c           | 显示真实的命令名称（用以启动该进程的程序名称）
    e           | 显示命令使用的环境变量
    f           | 用层级格式来显示进程， 显示哪些进程启动了哪些进程
    h           | 不显示头信息
    k soft      | 指定用于排序输出的列
    n           | 使用数值显示用户 ID 、组 ID 以及 WCHAN 信息
    w           | 为更宽的终端屏幕生成宽输出
    H           | 将线程显示为进程
    m           | 在进程之后显示线程
    L           | 列出所有的格式说明符
    V           | 显示 ps 命令的版本

- 在使用 BSD 风格的选项时， ps 命令会自动改变输出以模仿 BSD 格式。
- 注意，尽管上述很多输出列跟使用 Unix 风格选项时是一样的， 但还是有一些不同之处。
    - VSZ：进程占用的虚拟内存大小（以 KB 为单位）。
    - RSS ：进程在未被交换出时占用的物理内存大小。
    - STAT ：代表当前进程状态的多字符状态码。
- 多 字符状态码能比 Unix 风格输出的单字符状态码更清楚地表明进程的当前状态。第一个字符采用了与 Unix 风格的 S 输出列相同的值，表明进程是在休眠、运行还是等待。 第二个字符进一步说明了进程的状态。
    - <：该进程以高优先级运行。
    - N：该进程以低优先级运行。
    - L：该进程有锁定在内存中的页面。
    - s：该进程是控制进程。
    - l：该进程拥有多线程。
    - +：该进程在前台运行。

4. GNU 风格的ps 命令选项
    选项            | 描述
    ---             |---
    --deselect      | 显示除命令行中列出的进程之外的其他进程
    --Group grplist | 显示组 ID 在 grplist 列表中的进程
    --User userlist | 显示用户 ID 在 userlist 列表中的进程
    --group grplist | 显示有效组 ID 在 grplist 列表中的进程
    --user userlist | 显示有效用户 ID 在 userlist 列表中的进程
    --pid pidlist   | 显示 pid 在 pidlist 列表中的进程
    --ppid pidlist  | 显示父 pid 在 pidlist 列表中的进程
    --sid sidlist   | 显示会话 ID 在 sidlist 列表中的进程
    --tty ttylist   | 显示终端设备 ID 在 ttylist 列表中的进程
    --format format | 仅显示由 format 指定的列
    --context       | 显示额外的安全信息
    --cols n        | 将屏幕宽度设置为 n 列
    --columns n     | 将屏幕宽度设置为 n 列
    --cumulative    | 包含已停止的子进程的信息
    --forest        | 用层级结构显示出进程和父进程之间的关系
    --headers       | 在每页输出中都显示列名
    --no-headers    | 不显示列名
    --lines n       | 将屏幕高度设置为 n 行
    --rows n        | 将屏幕高度设置为 n 行
    --sort order    | 指定用于排序输出的列
    --width n       | 将屏幕宽度设置为 n 列
    --help          | 显示帮助信息
    --info          | 显示调试信息
    --version       | 显示 ps 命令的版本号

- 可以混用 GNU 长选项和 Unix 或 BSD 风格的选项来定制输出。
- 作为一个 GNU 长选项， --forest 选项着实讨人喜欢。该选项能够使用 ASCII 字符来绘制可爱的图表以显示进程的层级 信息，这种格式可以轻而易举地跟踪子进程和父进程。

5. 实时监测进程
- 与 ps 命令相似， top 命令也可以显示进程信息，但采用的是实时方式。
- top 命令运行时输出的第一部分显示的是系统概况：第一行显示了当前时间、系统的运行时长、登录的用户数以及系统的平均负载。
- 平均负载有 3 个值，分别是最近 1 分钟、最近 5 分钟和最近 15 分钟的平均负载。
    - 值越大说 明系统的负载越高。
    - 由于进程短期的突发性活动， 出现最近 1 分钟的高负载值也很常见。
    - 但如果近 15 分钟内的平均负载都很高，就说明系统可能有问题了。
- top 命令运行时的第二行显示了进程（top 称其为 task）概况：多少进程处于运行、休眠、停止以及僵化状态 （僵化状态指进程已结束， 但其父进程没有响应）。
- top 命令运行时的第三行显示了 CPU 概况。 top 会根据进程的属主（用户或是系统）和进程的状态（运行、空闲或等待） 将 CPU 利用率分成几类输出。
-  top 命令运行时的第四、五行详细说明了系统内存的状态。前一行显示了系统的物理内存状态： 总共有多少内存、当前用了多少，以及还有多少空闲。后一行显示了系统交换空间（如果分配了的话）的状态。
-  top 命令运行时的最后一部分显示了当前处于运行状态的进程的详细列表，有些列跟 ps 命令的输出类似。
    - PID：进程的 PID。
    - USER ：进程属主的用户名。
    - PR ：进程的优先级。
    - NI ：进程的谦让度。
    - VIRT ：进程占用的虚拟内存总量。
    - RES ：进程占用的物理内存总量。
    - SHR ：进程和其他进程共享的内存总量。
    - S：进程的状态（D 代表可中断的休眠，R 代表运行，S 代表休眠，T 代表被跟踪或停止，Z 代表僵化）。
    - %CPU：进程使用的 CPU 时间比例。
    - %MEM ：进程使用的可用物理内存比例。
    - TIME+：自进程启动到目前为止所占用的 CPU 时间总量。
    - COMMAND ：进程所对应的命令行名称，也就是启动的程序名。
- 在默认情况下， top 命令在启动时会按照%CPU 值来对进程进行排序，你可以在 top 命令运行时使用多种交互式命令来重新排序。每个交互式命令都是单字符，在 top 命令运行时键入可改变 top 的行为。键入 f 允许你选择用于对输出进行排序的字段， 键入 d 允许你修改轮询间隔（polling interval），键入 q 可以退出 top。

6. 结束进程
- 在 Linux 中，进程之间通过信号来通信。进程的信号是预定义好的一个消息，进程能识别该消息并决定忽略还是做出反应。进程如何处理信号是由开发人员通过编程来决定的。大多数编写完善的应用程序能接收和处理标准 Unix 进程信号。
- Linux 进程信号    
    信号 | 名称 | 描述
    ---|---|---
    1 | HUP | 挂起
    2 | INT | 中断
    3 | QUIT | 结束运行
    9 | KILL | 无条件终止
    11 | SEGV | 段错误
    15 | TERM | 尽可能终止
    17 | STOP | 无条件停止运行，但不终止
    18 | TSTP | 停止或暂停，但继续在后台运行
    19 | CONT | 在 STOP 或 TSTP 之后恢复执行

- 在 Linux 中有两个命令可以向运行中的进程发出进程信号： kill 和 pkill。
    - kill 命令可以通过 PID 向进程发送信号。在默认情况下， kill 命令会向命令行中列出的所有 PID 发送 TERM 信号。遗憾的是，你只能使用进程的 PID 而不能使用其对应的程序名，这使得 kill 命令有时并不好用。
        - 要发送进程信号，必须是进程的属主或 root用户。
        - TERM 信号会告诉进程终止运行。但不服管教的进程通常会忽略这个请求。如果要强制终止，则-s 选项支持指定其他信号（用信号名或信号值）。
        - kill 命令不会有任何输出。
        - 要检查 kill 命令是否生效，可以再次执行 ps 命令或 top 命令，看看那些进程是否已经停止运行。
    - pkill 命令可以使用程序名代替 PID 来终止进程。pkill 命令也允许使用通配符。
        - 以 root 身份使用pkill 命令时要格外小心。命令中的通配符很容易意外地将系统的重要进程终止。这可能会导致文件系统损坏。

7. 挂载存储设备
- Linux 文件系统会将所有的磁盘都并入单个虚拟目录。在使用新的存储设备之前，需要将其放在虚拟目录中。这项工作称为挂载（mounting）。
- 用于挂载存储设备的命令叫作 mount。在默认情况下， mount 命令会输出当前系统已挂载的设备列表。但是， 除了标准存储设备， 较新版本的内核还会挂载大量用作管理目的的虚拟文件系统。
- 如果知道设备分区使用的文件系统类型，可以像下面这样过滤输出。
    ```
    $ mount -t ext4
    ```
- mount 命令提供了 4 部分信息。
    - 设备文件名
    - 设备在虚拟目录中的挂载点
    - 文件系统类型
    - 已挂载设备的访问状态
- 要手动在虚拟目录中挂载设备，需要以 root 用户身份登录，或是以 root 用户身份运行 sudo 命令。下面是手动挂载设备的基本命令：
    ```
    mount -t type device directory
    ```
    - 其中， type 参数指定了磁盘格式化所使用的文件系统类型。
    - Linux 可以识别多种文件系统类型。 如果与 Windows PC共用移动存储设备， 那么通常需要使用下列文件系统类型。
        - vfat：Windows FAT32 文件系统，支持长文件名。
        - ntfs：Windows NT 及后续操作系统中广泛使用的高级文件系统。
        - exfat：专门为可移动存储设备优化的 Windows 文件系统。
        - iso9660：标准 CD-ROM 和 DVD文件系统。
    - 大多数 U 盘会使用 vfat 文件系统格式化。如果需要挂载数据 CD 或 DVD，则必须使用 iso9660文件系统类型。
    - 后面两个参数指定了该存储设备的设备文件位置以及挂载点在虚拟目录中的位置。
    - 例如， 手动将 U 盘/dev/sdb1 挂载到/media/disk，可以使用下列命令：
        ```
        mount -t vfat /dev/sdb1 /media/disk
        ```
- 一旦存储设备被挂载到虚拟目录， root 用户就拥有了对该设备的所有访问权限，而其他用户的访问则会被限制。可以通过目录权限指定用户对设备的访问权限。
- mount 命令选项
    选项        | 描述
    ---         |---
    -a          | 挂载/etc/fstab 文件中指定的所有文件系统
    -f          | 模拟挂载设备， 但并不真正挂载
    -F          | 和-a 选项一起使用时，同时挂载所有文件系统
    -v          | 详细模式，显示挂载设备的每一步操作
    -i          | 不使用/sbin/mount.filesystem 下的任何文件系统协助文件
    -l          | 自动给 ext2 、ext3 、ext4 或 XFS 文件系统添加文件系统标签
    -n          | 挂载设备，但不在/etc/mtab 已挂载设备文件中注册
    -p num      | 进行加密挂载时从文件描述符 num 中获得口令
    -s          | 忽略该文件系统不支持的挂载选项
    -r          | 将设备挂载为只读
    -w          | 将设备挂载为可读写（默认选项）
    -L label    | 将设备按指定的 label 挂载
    -U uuid     | 将设备按指定的 uuid 挂载
    -O          | 和-a 选项一起使用，限制其所作用的文件系统
    -o          | 给文件系统添加特定的选项

- mount 命令的 -o 选项允许在挂载文件系统时添加一系列以逗号分隔的额外选项。常用选项如下。
    - ro：以只读形式挂载。
    - rw：以读写形式挂载。
    - user：允许普通用户挂载该文件系统。
    - check=none：挂载文件系统时不执行完整性校验。
    - loop：挂载文件
- 移除可移动设备时，不能直接将设备拔下，应该先卸载。卸载设备的命令是 umount。
- Linux 不允许直接弹出已挂载的 CD 或 DVD 。如果在从光驱中移除 CD 或 DVD 时遇到麻烦，那么最大的可能是它还在虚拟目录中挂载着。应该先卸载， 然后再尝试弹出。
- umount 命令的格式：
    ```
    umount [directory | device ]
    ```
- umount 命令支持通过设备文件或者挂载点来指定要卸载的设备。如果有任何程序正在使用设备上的文件，则系统将不允许卸载该设备。
- 如果在卸载设备时，系统提示设备繁忙，无法卸载，那么通常是有进程还在访问该设备或使用该设备上的文件。这时可用 lsof 命令获得相关进程的信息，然后将进程终止。 lsof 命令的用法很简单： lsof /path/to/device/node， 或者 lsof /path/to/mount/point。

8. 使用 df 命令
- df 命令可以方便地查看所有已挂载磁盘的使用情况。
- df 命令会逐个显示已挂载的文件系统。与 mount 命令类似， df 命令会输出内核挂载的所有虚拟文件系统，因此可以使用-t 选项来指定文件系统类型， 进而过滤输出结果。该命令的输出如下。
    - 设备文件位置
    - 包含多少以 1024 字节为单位的块
    - 使用了多少以 1024 字节为单位的块
    - 还有多少以 1024 字节为单位的块可用
    - 已用空间所占的百分比
    - 设备挂载点
- df 命令的常用选项之一是-h，该选项会以人类易读（human-readable）的形式显示磁盘空间，通常用 M 来替代兆字节， 用 G 来替代吉字节。
- Linux 系统后台一直有进程在处理文件。 df命令的输出值反映的是Linux 系统认为的当前值。正在运行的进程有可能创建或删除了某个文件，但尚未释放该文件。这个值是不会被计算进闲置空间的。

9. 使用 du 命令
- du 命令可以显示某个特定目录（默认情况下是当前目录）的磁盘使用情况。这有助于你快速判断系统中是否存在磁盘占用“大户”。
- 在默认情况下，du 命令会显示当前目录下所有的文件、目录和子目录的磁盘使用情况，并以磁盘块为单位来表明每个文件或目录占用了多大存储空间。对标准大小的目录来说，输出内容可不少。
- 单纯的 du 命令的执行结果中，每行最左侧的数字是每个文件或目录所占用的磁盘块数。注意，这个列表是从目录层级的最底部开始，然后沿着其中包含的文件和子目录逐级向上的。
- 单纯的 du 命令作用并不大。下面这些选项能让 du 命令的输出更加清晰易读。
    -c：显示所有已列出文件的总大小。
    -h：按人类易读格式输出大小，分别用 K 表示千字节、 M 表示兆字节、 G 表示吉字节。
    -s：输出每个参数的汇总信息。

10. 数据排序
- 处理大量数据时的一个常用命令是 sort。sort 可以轻松地对大数据文件进行排序。
- 在默认情况下，sort 命令会依据会话所指定的默认语言的排序规则来对文本文件中的数据行进行排序。
- 在默认情况下，sort 命令会将数字视为字符并执行标准的字符排序，这种结果可能不是你想要的。可以使用-n 选项来解决这个问题，该选项会告诉 sort 命令将数字按值排序。
- 另一个常用的选项是-M，该选择可以将数字按月排序，sort 命令就能识别三字符的月份名(例如，Jan、Feb等)并正确排序。 Linux 的日志文件经常在每行的起始位置有一个时间戳，以表明事件是什么时候发生的。
- sort 命令选项
    短选项 | 长选项 | 描述
    ---|---|---
    -b | --ignore-leading-blanks    | 排序时忽略起始的空白字符
    -C | --check=quiet              | 不排序， 如果数据无序也不要报告
    -c | --check                    | 不排序， 但检查输入数据是否有序，无序的话就报告
    -d | --dictionary-order         | 仅考虑空白字符和字母数字字符，不考虑特殊字符
    -f | --ignore-case              | 大写字母默认先出现，该选项会忽略大小写
    -g | --general-numeric-sort     | 使用一般数值进行排序
    -i | --ignore-nonprinting       | 在排序时忽略不可打印字符
    -k | --key=POS1 [,POS2]         | 排序键从 POS1 位置开始， 到 POS2 位置结束（如果指定了 POS2 的话）
    -M | --month-sort               | 用三字符的月份名按月份排序
    -m | --merge                    | 合并两个已排序数据文件
    -n | --numeric-sort             | 将字符串按数值意义排序
    -o | --output=file              | 将排序结果写入指定文件
    -R | --random-sort              | 根据随机哈希排序
    -R | --random-source=FILE       | 指定-R 选项用到的随机字节文件
    -r | --reverse                  | 逆序排序（升序变成降序）
    -S | --buffer-size=SIZE         | 指定使用的内存大小
    -s | --stable                   | 禁止 last-resort 比较，实现稳定排序
    -T | --temporary-directory=DIR  | 指定用于保存临时工作文件的目录
    -t | --field-separator=SEP      | 指定字段分隔符
    -u | --unique                   | 和-c 选项合用时，检查严格排序；不和-c 选项合用时，相同行仅输出一次
    -z | --zero-terminated          | 在行尾使用 NULL 字符代替换行符
    
    - sort -u 等同于 sort | uniq
    - 在对按字段分隔的数据（比如/etc/passwd 文件）进行排序时， -k 选项和-t 选项非常方便。先使用-t 选项指定字段分隔符，然后使用-k 选项指定排序字段。例如，要根据用户 ID 对/etc/ passwd 按数值排序， 可以这么做：
        ```
        $ sort -t ':' -k 3 -n /etc/passwd
        root:x:0:0:root:/root:/bin/bash
        bin:x:1:1:bin:/bin:/sbin/nologin
        daemon:x:2:2:daemon:/sbin:/sbin/nologin
        adm:x:3:4:adm:/var/adm:/sbin/nologin
        lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
        sync:x:5:0:sync:/sbin:/bin/sync
        ...
        ```
        - 现在数据已经按第三个字段（用户 ID 的数值）排序妥当了。
    - -n 选项适合于排序数值型输出，比如 du 命令的输出：
        ```
        $ du -sh * | sort -nr
        1008k   mrtg-2.9.29.tar.gz
        972k    bldg1
        888k    fbs2.pdf
        760k    Printtest
        ...
        ```
        - -r 选项对数值按照降序排列，这样便能轻而易举地看出目录中的哪些文件占用磁盘空间最多。
        - 管道命令（|）用于将 du 命令的输出传入 sort 命令。
        
11. 数据搜索    
- grep 命令的格式如下：
    ```
    grep [options] pattern [file]
    ```
- grep 命令会在输入或指定文件中逐行搜索匹配指定模式的文本。该命令的输出是包含了匹配模式的行。
- 如果要进行反向搜索（输出不匹配指定模式的行），可以使用-v 选项。
- 如果要显示匹配指定模式的那些行的行号，可以使用-n 选项。
- 如果只想知道有多少行含有匹配的模式， 可以使用-c 选项。
- 如果要指定多个匹配模式，可以使用-e 选项来逐个指定。
- 在默认情况下， grep 命令使用基本的 Unix 风格正则表达式来匹配模式。 Unix 风格正则表达式使用特殊字符来定义如何查找匹配模式。
    ```
    $ grep [tf] file1
    ```
    - 正则表达式中的方括号表明 grep 应该搜索包含 t 字符或者 f 字符的匹配。如果不用正则表达式， 则 grep 搜索的是匹配字符串 tf 的文本。
- egrep 命令是 grep 的一个衍生， 支持 POSIX 扩展正则表达式，其中包含更多可用于指定匹配模式的字符。
- fgrep 则是另外一个版本，支持将匹配模式指定为以换行符分隔的一系列固定长度的字符串。这样就可以将这些字符串放入一个文件中，然后在 fgrep 命令中使用其搜索大文件中的字符串。

12. 数据压缩
- Linux 文件压缩工具
    工具 | 文件扩展名 | 描述
    ---|---|---
    bzip2       | .bz2  | 采用 Burrows-Wheeler 块排序文本压缩算法和霍夫曼编码 
    compress    | .Z    | 最初的 Unix 文件压缩工具，已经快要无人使用了
    gzip        | .gz   | GNU 压缩工具，用 Lempel-Zivwelch 编码
    xz          | .xz   | 日渐流行的通用压缩工具
    zip         | .zip  | Windows 中 PKZIP 工具的 Unix 实现

- gzip 软件包包括以下文件。
    - gzip ：用于压缩文件。
    - gzcat ：用于查看压缩过的文本文件的内容。
    - gunzip ：用于解压文件。
- gzip 命令会压缩命令行中指定的文件。也可以指定多个文件名或是用通配符来一次性压缩多个文件，gzip 命令会压缩该目录中匹配通配符的每个文件。

13. 数据归档
- tar 命令的格式如下。
    ```
    tar function [options] object1 object2 ...
    ```
- tar 命令的操作
    操作 | 长选项 | 描述
    ---|---|---
    -A | --concatenate  | 将一个 tar 归档文件追加到另一个 tar 归档文件末尾
    -c | --create       | 创建新的 tar 归档文件
    -d | --diff         | 检查归档文件和文件系统的不同之处
    |  | --delete       | 从 tar 归档文件中删除文件
    -r | --append       | 将文件追加到 tar 归档文件末尾
    -t | --list         | 列出 tar 归档文件的内容
    -u | --update       | 将比 tar 归档文件中已有的同名文件更新的文件追加到该归档文件 
    -x | --extract      | 从 tar 归档文件中提取文件

- 每种操作都使用 option（选项）来定义针对 tar 归档文件的具体行为。

- tar 命令选项
    选项 | 描述
    ---|---
    -C dir  | 切换到指定目录
    -f file | 将结果输出到文件（或设备）
    -j      | 将输出传给 bzip2 命令进行压缩
    -J      | 将输出传给 xz 命令进行压缩
    -p      | 保留文件的所有权限
    -v      | 在处理文件时显示文件名
    -z      | 将输出传给 gzip 命令进行压缩
    -Z      | 将输出传给 compress 命令进行压缩

    - 这些选项经常合并使用。可以用下列命令创建归档文件：
        ```
        // 该命令创建了一个名为 test.tar 的归档文件，包含目录 test和 test2 的内容
        tar -cvf test.tar test/ test2/
        
        // 该命令列出了（但不提取）tar 文件 test.tar 的内容
        tar -tf test.tar
        
        // 该命令从 tar 文件 test.tar 中提取内容。如果创建的时候 tar 文件含有目录结构，则在当前目 录中重建该目录的整个结构。
        tar -xvf test.tar
        ```
    - tar 命令可以轻松地为整个目录结构创建归档文件。这是在 Linux 中分发开源程序源代码文件所采用的普遍方法。    
- 在下载开源软件时经常会看到文件名以.tgz 结尾，这是经 gzip压缩过的 tar 文件，可以用命令 tar -zxvf filename.tgz 来提取其中的内容。
