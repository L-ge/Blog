1. movetothread怎么实现的？
- 改变了threadData这个结构体的数据，例如 threadid。
- 不能对有父对象（parent 属性）的对象使用QObject::moveToThread()函数

2. QList 和 std::list 的底层实现有什么区别？
- QList 好像是基于 QByteArray 的，好像没有next指针这个东西。

3. Qt的内存管理是怎么做的？
- 半自动内存管理机制。有个 QObject 对象树。
- QObject及其派生类的对象，如果其parent非0，那么其parent析构时会析构该对象。

4. 继承QObject的类怎么析构？
- 析构的时候，将其从对象树摘掉。

5. moc是什么？
- 元对象系统。

6. QVector的底层数据结构是什么？
- QByteArray，字节数组。

7. C++二进制兼容性问题？Qt的d指针。
- 具体就是不能改动态库接口。

8. connect第5个参数，分别都有什么用？队列绑定是怎么实现的？信号槽跨线程是怎么实现的？它怎么知道是否在同一个线程？
- 改变了threadData这个结构体的数据，例如 threadid。

9. deletelater是怎么实现的？为什么要这么做？
- 不马上delete，会包装成一个事件，扔到事件循环里面去。

10. Windows的消息机制、Qt的消息机制？
- 每个线程有自己的事件循环。

11. QObject对象的析构是线程安全的吗？
- 不是？

12. QString 和 std::string 的底层实现有什么区别？
	```
	// 32位平台
	QString s1;
    std::string s2;

    qDebug() << "fin1:" << sizeof(s1);  // 4
    qDebug() << "fin2:" << sizeof(s2);  // 24
	```

13. std::shared_ptr 是线程安全的吗？
不是。引用计数是线程安全的，因为用的都是原子变量。

14. 静态变量析构的时候，调用另一个静态变量怎么办？静态变量的析构顺序？
- C++全局静态变量的析构销毁顺序是未定义的，特别是在多线程环境，多dll环境下，特别复杂。
- 如果是单线程的话，建议用指针的方式，在AppInit的时候构造，在AppExit的时候delete，并设置为0。别的地方引用的时候先判断。
- 保证构造顺序？

15. std::unique_ptr有时候sizeof是4个字节大小？底层实现是怎样的？
- tuple实现？成员变量是个tuple？

16. Windows系统求CPU占用率是没有系统API的，那怎么求？
- 计算用户态时间和内核态消耗的时间之和，除以时间间隔。
- 通过 GetSystemTimes(&IdleTime, &KernelTime, &UserTime); 系统API获得总时间、内核时间、用户态时间。

17. 信号槽传参，如果要传递自己定义的结构体/类/对象，需要做些什么？
- 在main()函数中注册这种类型：qRegisterMetaType(“MyClass”);
- Q_DECLARE_METATYPE(MyClass); //在自定义类或者结构体等声明后紧接着用宏Q_DECLARE_METATYPE声明自定义自定义数据类型 
- 为了QMetaType直接能够识别，自己进加到他的元对象系统？

18. stdcall 与 cdcall 的区别？
- __stdcall的全称是standard call。是C++的标准调用方式。函数参数的入栈顺序为从右到左入栈。函数返回时使用ret x指令，其中x为调整堆栈的字节数。这种方式叫做自动清栈。即被调用的函数的参数个数是固定的，调用者必须严格按照定义传递参数，一个不多，一个不少。
- __cdecl的全称是C Declaration，即C语言默认的函数调用方式。函数参数的入栈顺序为从右到左入栈。函数返回时作用ret指令。由调用者手动清栈。被调用的函数支持可变参数。调用者根据调用时传入参数的个数，手动平衡堆栈。
- 两者的相同点与不同点
	- 相同点
		- 参数入栈顺序相同：从右到左
	- 不同点
		- 堆栈平衡方式不同：__stdcall自动清栈，__cdecl手动清栈。
		- 返回指令不同：_stdcall使用retn x, __cdecl使用ret
		- 编译后函数的修饰名不同： 假设有函数int foo(int a, int b), 采用__stdcall编译后的函数名为_foo@8，而采用__cdecl编译后的函数名为_foo。
	- 从函数调用看，b和a依次被push进堆栈，而在函数中又通过相对于ebp(即刚进函数时的堆栈指针）的偏移量存取参数。函数结束后，ret 8表示清理8个字节的堆栈，函数自己恢复了堆栈。
- __fastcall：快速调用方式。所谓快速，这种方式选择将参数优先从寄存器传入（ECX和EDX），剩下的参数再从右向左从栈传入。因为栈是位于内存的区域，而寄存器位于CPU内，故存取方式快于内存，故其名曰“__fastcall”。

19. shared_from_this()的实现原理
- enable_shared_from_this的一种实现方法是，其内部有一个weak_ptr类型的成员变量_Wptr，当shared_ptr构造的时候，如果其模板类型继承了enable_shared_from_this，则对_Wptr进行初始化操作，这样将来调用shared_from_this函数的时候，就能够通过weak_ptr构造出对应的shared_ptr。

20. Qt的自定义控件，有搞过吗？

21. Qt除了QThread外的线程库有用过吗？
QThreadPool、QtConcurrent

22. windows窗口通信是怎么样的？原理？
SendMessage。

23. 如何判断两个类的类型是否一致？
- 利用typeid
- 利用模板特化
- 多态？

24. 类型信息是存放在哪里的？
- typeid 会将类的相关信息存储到一个类型为 type_info（头文件）的对象中，在调用 typeid 后返回这个对象的常引用（type_info const&）。
- 每个带有虚函数的类型的对象都有 vptr（虚函数表指针）指向虚函数表，利用这个特点，C++ 在对象的虚函数表的“上面”存储了一个指针，该指针指向 .data 段中的 type_info 对象。从而实现从对象找到 type_info。
- https://blog.csdn.net/m0_37701628/article/details/117490063

25. QTimer精度问题
- https://zhuanlan.zhihu.com/p/50488956

26. QTime精度问题
- QTime表示的时间的精度取决于操作系统本身的精度,并不是所有的系统都能提供1ms级别的精度。

27. 单例模式饿汉模式：在程序初始化的时候就构建好实例对象，在程序运行过程直接使用。
- 缺点是全局变量析构的顺序无法保证。
- 所以，建议用懒汉模式，用指针的方式，加一个destroy方法，我们自己控制析构顺序。

28. QScopedPointer是基于范围的指针，std::unique_ptr是控制权唯一的指针，它俩不是对应关系。
- QScopedPointer没有实现移动语义。 



## 其他重点

- 排序算法
- 反转链表
- 信号槽的运行机制
- 界面通信、窗口通信的原理
- 崩溃问题
- 算法基础-20页
- 高频算法题-20页
- QThreadPool
- 设计模式（观察者、外观、中介者）
- MD、MT是什么？
	- MT和MD的区别    （1）/MD，表示运行时库由操作系统提供一个DLL，程序里不集成。编译出来的文件比较小。使用的库文件是  MSVCRT.lib
	（2）/MT，表示运行时库由程序集成。编译出来的文件比较大。在运行的机器上不需要安装依赖的VS的动态库，使用的库文件是  LIBCMT.lib
	- 如果所有模块都是可以编译的，则选择相同的编译选项即可，如果存在第三方引用的库，运行的时候可能存在版本不一致的问题。

	- 遇到MSVCRT.lib和LIBCMT.lib冲突的问题，一般就是编译选项不一致的问题
- Top k问题。
- 超多数排序问题。
- 为什么动态绑定必须是指针或引用？而不能是对象？
	- 对象的赋值是调用了拷贝构造函数。


排序算法有哪些？
基数排序有了解吗？
快速排序是怎样的？（冒泡排序、快速排序、归并排序出现的频率都很高）
图的算法？
红黑树如何保持平衡？
有了解过其他平衡树吗？
- std::sort是怎么实现的？
	- 基本框架如下图所示：
		1. 判断输入数据个数是否小于给定阈值，如果是，则直接进行插入排序
		2. 否则，判断递归深度是否小于阈值，如果是，进行快速排序
		3. 否则，进行堆排序
		4. 循环1,2,3

大小堆是怎么调整的？
一个exe的加载执行过程？
	- 首先：从父进程复制出一个子进程。图形界面、命令行程序就是父进程。当双击图标，执行程序时会从父进程复制出子进程，复制的目的其实就是从父进程的 “虚拟内存”复制出一个子进程的“虚拟内存”，准确讲应该是复制出“虚拟内存”的task进程数据结构，用于建立子进程的虚拟内存。有了子进程的虚拟内存，就可以将新的程序加载到虚拟内存中了。
	- 每个进程的虚拟内存和物理内存是一一对应的，每个进程虚拟对内对应不同的物理内存，这也是为什么每个进程的虚拟地址都是0x08048000，而不会与物理地址重复。
	- 然后，程序运行起来就编程进程了。程序加载时候，linux提供的加载器将程序的代码段和数据段加载到进程的应用空间中，加载到0x08048000地址处。所有的进程都共享内核空间。
	- 程序被加载到虚拟内存后，程序就可以运行了，运行后就是动态的进程了。进程运行过程如下：
	（a）cpu的pc指向_start（将start第一条指令——start所在位置的虚拟地址存放到pc）
	（b）从_start开始执行启动代码。
	（c）启动代码调用_init等函数进行初始化。其中很重要的就是弄出堆和栈这两个东西
	（d）启动代码调用main函数，main函数再调用各个子函数，我们自己写的代码就开始运行了。	（e）main函数调用return关键字，返回到启动代码。main函数将返回值return给启动代码后，启动代码会调用exit函数，接着将返回值返回给OS。该返回值主要是为了获取子进程的“进程状态”，从而回收子进程的资源。
	- 加载新程序之前，子进程中的所有内容（包括堆和栈），都是从父进程复制（继承）而来，子进程的.text、.data、…、堆栈与父进程的一模一样。当exec加载新程序后，新程序的.text、.rodata、.data等会覆盖子进程原有的.text、.rodata、.data、.bss，然后开始执行新程序。执行新程序时还是从.text中的“启动代码”开始执行的，当执行启动代码中设置堆栈的代码时，会重新设置新程序自己的堆栈指针，此时所代表的就是新程序自己的堆栈，只不过堆栈空间还是子进程的堆栈空间，并且该空间不会被清零（memset 或 bzero清零）。
main函数前后做了什么？
Windows内核对象是什么？
	- https://zhuanlan.zhihu.com/p/604642852?utm_id=0
TCP和UDP可以同时使用同一个端口号吗？
从汇编的角度讲一下函数调用的过程？
	- 栈帧：即函数运行在栈上所开辟出的一块空间，栈帧中保存了该函数的返回地址和局部变量的这部份内容的空间。
	- 当前正在调用的是那个函数，那么ebp 与esp就是维护的就是当前函数的函数栈帧。 
	- https://www.bilibili.com/read/cv18562071/
- 函数返回地址先入栈还是形参先入栈？
	- 返回地址先入栈。
	- 我们从调用开始到调用结束一步步分析一下：（假设main函数调用add函数）
	- 当我们调用函数时，栈的变化如下：
		1. 首先，会将原函数main函数的返回地址压入栈中，返回地址就是add函数下一条指令的地址，因为函数返回后就要执行这个指令了。
		2. 将原函数main的rbp栈底指针入栈，因为函数返回后还要维护main函数的栈底指针，main函数并没有执行完成。
		3. 将栈顶指针rsp的值赋给rbp,然后将栈顶指针减去一定的数值，为新的函数开辟空间。这里要注意，栈顶指针永远指向栈顶，所以当把rsp赋给rbp时，rbp已经指向原来main的栈顶+返回地址+main的rbp了那个位置了。
		4. 上面都是准备工作，接下来就是在那段空间进行一系列操作。比如存储函数参数的值（movl $1 %rbp-4就是将参数1放到栈底的上一个位置，栈是高地址向低地址增长的，所以要减），将值赋给寄存器等。如果有返回值，返回值会放到eax寄存器中。
		5. 栈中弹出main函数栈的rbp地址，赋值给rbp寄存器，即恢复main函数的rbp.
		6. leave,RET退出调用。ret指令则是将栈顶的返回地址弹出到EIP，然后按照EIP此时指示的指令地址继续执行程序。leave指令相当于将rbp赋给rsp，并把rbp出栈，将里面的值赋给rbp寄存器（相当于步骤5）可以看到5,6和2,1是配对的，因为栈是后进先出。
		7. 最后还可能有返回值，从eax取出赋给main函数的局部变量处，将eax置零。
